[
  {
    "objectID": "docs/index.html",
    "href": "docs/index.html",
    "title": "nbquarto",
    "section": "",
    "text": "nbquarto is a small python library built around the idea of creating quick extensions (Processors) to use in Quarto projects.\nThe general idea is that a Processor handles a “cell” in a notebook (or qmd eventually) and modifies its contents for documentation purposes (but can be used for other things). This project is built on the idea (and most of the code) from the nbdev project by fast.ai, however it explicitly removes any magicalness from the code and creates a library that is purely “pythonic”. In doing so, it’s also more flexible and easier for users to use.\n\n\n\ncell: A singular module or item in a Jupyter Notebook, of which can either execute code written in it or contain Markdown that will be presented to a reader or on a Quarto website\ndirective: A comment block in a notebook cell that Quarto (and nbquarto) can process or recognize. Generally denoted with a pipe (|) after the comment, such as #| directive or # | directive\nProcessor: A class which modifies a cell in a Jupyter Notebook\n\n\n\n\nAs mentioned earlier, a Processor take the content in any Jupyter Notebook cell and modify it in some way. The original design intention was to inject Quarto-specific nuonces into the cell to help with code formatting, or to write quick shortcuts to create complex combinations in quarto syntax on the fly.\nThe following is a small snippet (taken from the official example processor) which simply injects the code:\n# This code has been processed!\nto the top of any cell.\nfrom nbquarto import Processor\n\nclass BasicProcessor(Processor):\n    \"\"\"\n    A basic processor that adds a comment to the top of a cell\n    \"\"\"\n\n    directives = \"process\"\n\n    def process(self, cell):\n        if any(directive in cell.directives_ for directive in self.directives):\n            cell.source = f\"# This code has been processed!\\n{cell.source}\"\nThe process function is what will get applied to the notebook cell, after checking if any directives to look for exist in the cell.\n\n\n\nAfter either creating your own processor, or deciding what processor to use, a config file should be generated that contains the exact imports for processors you want to use, and where processed notebooks should be sent to.\nSee below for an example, located here in the repo:\noutput_folder: processed_notebooks\nprocessors: [\n  nbquarto.processors.example:BasicProcessor\n]\nThis reads as follows: - output_folder: All notebooks will be saved to a (potentially new) processed_notebooks directory - processors: This contains the list of processors we want to apply - nbquarto.processors.example:BasicProcessor: This is the exact import for the processor to apply\n\n\n\nFinally, by calling the nbquarto-process command you can process notebooks with your configured Processor(s):\nnbquarto-process --config_file tests/test_artifacts/single_processor.yaml --notebook_file tests/test_artifacts/test_example.ipynb"
  },
  {
    "objectID": "docs/package_reference/notebook.html",
    "href": "docs/package_reference/notebook.html",
    "title": "",
    "section": "",
    "text": "Notebook Utilities\n\nFunctions to help with processing of notebooks. Most come from nbdev\n\n\nNotebookCell\n<source>\n\n(index: int, cell: dict)\n\n\nA cell for a Jupyter Notebook\n\n\nset_source\n<source>\n\n(source: list)\n\n\nParameters:\n\nsource (list) – The source of the cell as a list of strings\n\nSets the source attribute of the cell as a string and removes parsed directives\n\n\n\n\nnbquarto.notebook.dict2notebook\n<source>\n\n(d: dict = None, **kwargs)\n\n\nParameters:\n\nd (dict, optional, defaults to None) – A dictionary to convert\n\nConverts dictionary d to an AttributeDictionary\n\n\n\nnbquarto.notebook.read_notebook\n<source>\n\n(path: str)\n\n\nParameters:\n\npath (str) – The path to the Jupyter Notebook\n\nReads a Jupyter Notebook from a filepath\n\n\n\nnbquarto.notebook.write_notebook\n<source>\n\n(notebook: AttributeDictionary, path: str)\n\n\nParameters:\n\nnotebook (AttributeDictionary) – An object representing all the cells in a Jupyter Notebook\npath (str) – The path to the Jupyter Notebook\n\nWrites the contents of notebook to path\n\n\n\nnbquarto.notebook.new_notebook\n<source>\n\n(cells: list = [], metadata: dict = {}, nbformat: int = 4, nbformat_minor: int = 5)\n\n\nParameters:\n\ncells (list of NotebookCell, optional, defaults to []) – A list of cells to make up the notebook\nmetadata (dict, optional, defaults to &lcub;}) – Metadata for the notebook\nnbformat (int, optional, defaults to 4) – The nbformat of the notebook\nnbformat_minor (int, optional, defaults to 5) – The minor nbformat version of the notebook\n\nCreates a new empty notebook\n\n\n\nnbquarto.notebook.make_cell\n<source>\n\n(text: str, cell_type: str = ‘code’, **kwargs)\n\n\nParameters:\n\ntext (str) – The source code for the cell\ncell_type (str, optional, defaults to “code”) – The type of cell to make, must be one of “code”, “markdown”, or “raw” kwargs – Additional arguments to pass to the cell, such as metadata\n\nMakes a blank notebook cell"
  },
  {
    "objectID": "docs/package_reference/processors.html",
    "href": "docs/package_reference/processors.html",
    "title": "",
    "section": "",
    "text": "Processors\n\nThe various Processor classes available to use\n\n\nBasicProcessor\n<source>\n\n(notebook: AttributeDictionary)\n\n\nA basic processor that adds a comment to the top of a cell\n\n\n\nAutoDocProcessor\n<source>\n\n(notebook, processor_args: dict = {})\n\n\nA processor which will automatically generate API documentation for a given class or method. Largely relies on the implementation in hf-doc-builder, while adding some customizations for Quarto.\nThis processor expects the following directives:\n\nautodoc, (str): Should contain the exact import location (or relative) of an object or function to document, such as nbquarto.processors.AutoDocProcessor.\nmethods, (List[str], optional): A list of methods to expose for the specified class. If nothing is passed, all public methods will be documented. If special methods should be documented including all special methods, such as __call__, the key all can be passed along with the special methods to document.\n\nExamples:\nTo expose all public methods:\n#| autodoc: nbquarto.processors.AutoDocProcessor\nTo specify specific functions to document along with the init:\n#| autodoc nbquarto.processors.AutoDocProcessor\n#| methods process\nTo expose all public methods and include special or hidden methods:\n#| autodoc nbquarto.processors.AutoDocProcessor\n#| methods all, __call__\n\n\n\nCodeNoteProcessor\n<source>\n\n(notebook: AttributeDictionary)\n\n\nA processor which checks and reorganizes cells for documentation with the proper explanations\nSpecifically will look at source code cells that have markdown cells following them. Each markdown cell should contain #| explain followed by a selection of the source code the markdown cell is explaining. The processor will then create a panel tabset with the original code and the new explanation.\nFor example:\nIn a code cell:\ndef addition(a,b):\n    return a+b\nIn a subsequent markdown cell:\n#| explain `addition(a,b)`\nThis function adds two numbers together"
  },
  {
    "objectID": "docs/package_reference/processor.html",
    "href": "docs/package_reference/processor.html",
    "title": "",
    "section": "",
    "text": "The Processor\n\nThe base class for all notebook processors\n\n\nProcessor\n<source>\n\n(notebook: AttributeDictionary)\n\n\nBase class for all notebook processors. Any processors should inherit this class.\nWhen writing a processor, you can override methods that modify the content of a cell with the process_cell function.\nThe class stores the entire notebook in the notebook attribute.\nWhen using a processor, simply call the class and pass in a single cell.\nExample:\nclass BasicProcessor(Processor):\n    \"A basic processor that adds a comment to the top of a cell\"\n    directive = \"process\"\n\n    def process(self, cell):\n        cell.source = f\"# This code has been processed!\\n&amp;lcub;cell.source}\"\n\n\nhas_directives\n<source>\n\n(cell: AttributeDictionary)\n\n\nChecks if cell contains any directives in self.directives\n\n\n\nprocess\n<source>\n\n(cell: AttributeDictionary)\n\n\nParameters:\n\ncell (AttributeDictionary) – A cell from a Jupyter Notebook\n\nA function to apply on a cell. Should use self.has_directives to see if the processor should be applied\nExample:\ndef process(self, cell):\n    if self.has_directives(self, cell):\n        cell.source = \"Found a directive!\"\n\n\n\nprocess_cell\n<source>\n\n(cell: AttributeDictionary)\n\n\nParameters:\n\ncell (AttributeDictionary) – A cell from a Jupyter Notebook\n\nApplies the processor to a cell if the cell is of the correct type and contains the correct directive\n\n\n\n\nNotebookProcessor\n<source>\n\n(path: str = None, processors: list = [], notebook: AttributeDictionary = None, config: dict = {}, debug: bool = False, remove_directives: bool = True, process_immediately: bool = False)\n\n\n\n\n\nprocess_cell\n<source>\n\n(processor: callable, cell: AttributeDictionary)\n\n\nParameters:\n\nprocessor (callable) – A function to apply to a notebook cell’s content\ncell (AttributeDictionary) – A cell from a Jupyter Notebook\n\nProcesses a single cell of a notebook. Should not be called explicitly and instead a user should use process_notebook\n\n\n\nprocess_notebook\n<source>\n\n()\n\n\nProcesses the content of the notebook"
  }
]