[
  {
    "objectID": "package_reference/notebook.html",
    "href": "package_reference/notebook.html",
    "title": "",
    "section": "",
    "text": "Notebook Utilities\n\nFunctions to help with processing of notebooks. Most come from nbdev\n\n\nNotebookCell\n<source>\n\n(index: int, cell: dict)\n\n\nA cell for a Jupyter Notebook\n\n\nset_source\n<source>\n\n(source: list)\n\n\nParameters:\n\nsource (list) – The source of the cell as a list of strings\n\nSets the source attribute of the cell as a string and removes parsed directives\n\n\n\n\nnbquarto.notebook.dict2notebook\n<source>\n\n(d: dict = None, **kwargs)\n\n\nParameters:\n\nd (dict, optional, defaults to None) – A dictionary to convert\n\nConverts dictionary d to an AttributeDictionary\n\n\n\nnbquarto.notebook.read_notebook\n<source>\n\n(path: str)\n\n\nParameters:\n\npath (str) – The path to the Jupyter Notebook\n\nReads a Jupyter Notebook from a filepath\n\n\n\nnbquarto.notebook.write_notebook\n<source>\n\n(notebook: AttributeDictionary, path: str)\n\n\nParameters:\n\nnotebook (AttributeDictionary) – An object representing all the cells in a Jupyter Notebook\npath (str) – The path to the Jupyter Notebook\n\nWrites the contents of notebook to path\n\n\n\nnbquarto.notebook.new_notebook\n<source>\n\n(cells: list = [], metadata: dict = {}, nbformat: int = 4, nbformat_minor: int = 5)\n\n\nParameters:\n\ncells (list of NotebookCell, optional, defaults to []) – A list of cells to make up the notebook\nmetadata (dict, optional, defaults to &lcub;}) – Metadata for the notebook\nnbformat (int, optional, defaults to 4) – The nbformat of the notebook\nnbformat_minor (int, optional, defaults to 5) – The minor nbformat version of the notebook\n\nCreates a new empty notebook\n\n\n\nnbquarto.notebook.make_cell\n<source>\n\n(text: str, cell_type: str = ‘code’, **kwargs)\n\n\nParameters:\n\ntext (str) – The source code for the cell\ncell_type (str, optional, defaults to “code”) – The type of cell to make, must be one of “code”, “markdown”, or “raw” kwargs – Additional arguments to pass to the cell, such as metadata\n\nMakes a blank notebook cell"
  },
  {
    "objectID": "package_reference/processors.html",
    "href": "package_reference/processors.html",
    "title": "",
    "section": "",
    "text": "Processors\n\nThe various Processor classes available to use\n\n\nBasicProcessor\n<source>\n\n(notebook: AttributeDictionary)\n\n\nA basic processor that adds a comment to the top of a cell\n\n\n\nAutoDocProcessor\n<source>\n\n(notebook, processor_args: dict = {})\n\n\nA processor which will automatically generate API documentation for a given class or method. Largely relies on the implementation in hf-doc-builder, while adding some customizations for Quarto.\nThis processor expects the following directives:\n\nautodoc, (str): Should contain the exact import location (or relative) of an object or function to document, such as nbquarto.processors.AutoDocProcessor.\nmethods, (List[str], optional): A list of methods to expose for the specified class. If nothing is passed, all public methods will be documented. If special methods should be documented including all special methods, such as __call__, the key all can be passed along with the special methods to document.\n\nExamples:\nTo expose all public methods:\n#| autodoc: nbquarto.processors.AutoDocProcessor\nTo specify specific functions to document along with the init:\n#| autodoc nbquarto.processors.AutoDocProcessor\n#| methods process\nTo expose all public methods and include special or hidden methods:\n#| autodoc nbquarto.processors.AutoDocProcessor\n#| methods all, __call__\n\n\n\nCodeNoteProcessor\n<source>\n\n(notebook: AttributeDictionary)\n\n\nA processor which checks and reorganizes cells for documentation with the proper explanations\nSpecifically will look at source code cells that have markdown cells following them. Each markdown cell should contain #| explain followed by a selection of the source code the markdown cell is explaining. The processor will then create a panel tabset with the original code and the new explanation.\nFor example:\nIn a code cell:\ndef addition(a,b):\n    return a+b\nIn a subsequent markdown cell:\n#| explain `addition(a,b)`\nThis function adds two numbers together"
  },
  {
    "objectID": "package_reference/processor.html",
    "href": "package_reference/processor.html",
    "title": "",
    "section": "",
    "text": "The Processor\n\nThe base class for all notebook processors\n\n\nProcessor\n<source>\n\n(notebook: AttributeDictionary)\n\n\nBase class for all notebook processors. Any processors should inherit this class.\nWhen writing a processor, you can override methods that modify the content of a cell with the process_cell function.\nThe class stores the entire notebook in the notebook attribute.\nWhen using a processor, simply call the class and pass in a single cell.\nExample:\nclass BasicProcessor(Processor):\n    \"A basic processor that adds a comment to the top of a cell\"\n    directive = \"process\"\n\n    def process(self, cell):\n        cell.source = f\"# This code has been processed!\\n&amp;lcub;cell.source}\"\n\n\nhas_directives\n<source>\n\n(cell: AttributeDictionary)\n\n\nChecks if cell contains any directives in self.directives\n\n\n\nprocess\n<source>\n\n(cell: AttributeDictionary)\n\n\nParameters:\n\ncell (AttributeDictionary) – A cell from a Jupyter Notebook\n\nA function to apply on a cell. Should use self.has_directives to see if the processor should be applied\nExample:\ndef process(self, cell):\n    if self.has_directives(self, cell):\n        cell.source = \"Found a directive!\"\n\n\n\nprocess_cell\n<source>\n\n(cell: AttributeDictionary)\n\n\nParameters:\n\ncell (AttributeDictionary) – A cell from a Jupyter Notebook\n\nApplies the processor to a cell if the cell is of the correct type and contains the correct directive\n\n\n\n\nNotebookProcessor\n<source>\n\n(path: str = None, processors: list = [], notebook: AttributeDictionary = None, config: dict = {}, debug: bool = False, remove_directives: bool = True, process_immediately: bool = False)\n\n\n\n\n\nprocess_cell\n<source>\n\n(processor: callable, cell: AttributeDictionary)\n\n\nParameters:\n\nprocessor (callable) – A function to apply to a notebook cell’s content\ncell (AttributeDictionary) – A cell from a Jupyter Notebook\n\nProcesses a single cell of a notebook. Should not be called explicitly and instead a user should use process_notebook\n\n\n\nprocess_notebook\n<source>\n\n()\n\n\nProcesses the content of the notebook"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "nbquarto",
    "section": "",
    "text": "nbquarto is a python interface to quickly interact with, modify, and overall process the cells in a Jupyter Notebook, generally to be utilized in Quarto projects. (However that is not a requirement at all!)\n\n\nnbquarto takes all of its inspiration from the nbdev project by fast.ai, and reimplements the core part of it, the Processor, in a way that entices code readability, better error management, and an easier user experience overall.\nI’ve tried to write projects like nbquarto multiple times, most recently through the nbdev-extensions, however for my general use-case of someone who just wanted to modify the notebooks with specific markup for whatever processor I wanted to include (such as an automatic API-documentation generator), having the entire framework nbdev advertised was just far too much for what I wanted to do, along with the dangers of using a library that is exceedingly cryptic and with hard-to-read source code due to so much abstraction.\nnbquarto removes almost all of the abstraction, and its dependencies are exceedingly minimal, allowing for anyone who wants to pick up this project to easily understand just what is happening under the hood and do what they want.\n\n\n\nTrue, quarto extensions are already a thing, but I didn’t enjoy the fact I had to go learn an entirely new language (Lua) to modify content that was already (in this case) in Python. As a result, nbquarto acts as a pythonic-version of Lua in its processing capabilities. While we sacrifice some processing speed (because it is still python), the benefit of a flexible and easy-to-follow paradigm for creating these extensions far outweights the extra minimal seconds added to process each notebook.\n\n\n\n\ncell: A singular module or item in a Jupyter Notebook, of which can either execute code written in it or contain Markdown that will be presented to a reader or on a Quarto website\ndirective: A comment block in a notebook cell that Quarto (and nbquarto) can process or recognize. Generally denoted with a pipe (|) after the comment, such as #| directive or # | directive\nProcessor: A class which modifies a cell in a Jupyter Notebook depending on the directive(s) present in it.\n\n\n\n\nThe general idea of nbquarto revolves around a Processor. The original design intention was to inject Quarto-specific nuonces into the cell to help with code formatting, or to write quick shortcuts to create complex combinations in quarto syntax on the fly.\nThe following is a small snippet (taken from the official example processor) which simply injects the code:\n# This code has been processed!\nto the top of any cell.\nfrom nbquarto import Processor\n\nclass BasicProcessor(Processor):\n    \"\"\"\n    A basic processor that adds a comment to the top of a cell\n    \"\"\"\n\n    directives = \"process\"\n\n    def process(self, cell):\n        if any(directive in cell.directives_ for directive in self.directives):\n            cell.source = f\"# This code has been processed!\\n{cell.source}\"\nThe process function is what will get applied to the notebook cell, after checking if any directives to look for exist in the cell.\ncell objects contain two important aspects of information we can look at: - directives_: list[str], a list of directives in the cell, such as process if it were written as #| process - source: The text that exists inside the cell that you might want to modify\nBy utilizing these two simplistic properties, one can create amazing extensions such as ones to automatically generate API documentation or create helpful side-by-side code explanations\n\n\n\nnbquarto utilizes a configuration file to handle all of the nuonces related to the processors to use, where the notebooks should be sent to, and can even handle setting any constants for Processors that they may want.\nFor example, located here in the repo:\ndocumentation_source: tests\nprocessors: [\n    nbquarto.processors.example:BasicProcessor,\n    nbquarto.processors.autodoc:AutoDocProcessor\n]\n\nprocessor_args:\n  AutoDocProcessor: \n      repo_owner: muellerzr\n      repo_name: nbquarto\nThis reads as follows:\n\noutput_folder: All notebooks will be saved to a (potentially new) processed_notebooks directory\nprocessors: This contains the list of processors we want to apply\n\nnbquarto.processors.example:BasicProcessor and nbquarto.processors.autodoc:AutoDocProcessor: This is the exact import for the processor to apply. Can also be relative if the package is setup for it (so it could be nbquarto.processors:AutoDocProcessor)\n\nprocessor_args: This contains a list of processor: args that should be passed all the time to a particular processor, if it takes in special configuration arguments\n\nAutoDocProcessor: This is the name of the processor that will take in arguments following it\n\nrepo_name and repo_owner: These are arguments the AutoDocProcessor accepets upon its __init__.\n\n\n\n\n\n\nBy calling the nbquarto-process command you can process notebooks with your configured Processor(s):\nnbquarto-process --config_file tests/test_artifacts/single_processor.yaml --notebook_file tests/test_artifacts/test_example.ipynb --output_folder docs/\nAfterwards, all of the processed notebooks are saved as qmd files in output_folder and can be modified directly, if you so choose. As you can specify already existing folders, you can have docs contain all of your regular documentation, and then expect that nbquarto will create the qmd files in the same directory structure it was in before except now in docs."
  }
]